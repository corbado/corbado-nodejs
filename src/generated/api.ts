/* tslint:disable */
/* eslint-disable */
/**
 * Corbado Backend API
 *  # Introduction This documentation gives an overview of all Corbado Backend API calls to implement passwordless authentication with Passkeys. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@corbado.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Application type
 * @export
 * @enum {string}
 */

export const AppType = {
    Empty: 'empty',
    Web: 'web',
    Native: 'native'
} as const;

export type AppType = typeof AppType[keyof typeof AppType];


/**
 * 
 * @export
 * @interface AuthEvent
 */
export interface AuthEvent {
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    'authEventID': string;
    /**
     * ID of the user
     * @type {string}
     * @memberof AuthEvent
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof AuthEvent
     */
    'username': string;
    /**
     * 
     * @type {AuthEventType}
     * @memberof AuthEvent
     */
    'eventType': AuthEventType;
    /**
     * 
     * @type {AuthEventMethod}
     * @memberof AuthEvent
     */
    'method': AuthEventMethod;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof AuthEvent
     */
    'created': string;
    /**
     * 
     * @type {AuthEventStatus}
     * @memberof AuthEvent
     */
    'status': AuthEventStatus;
}


/**
 * 
 * @export
 * @interface AuthEventCreateReq
 */
export interface AuthEventCreateReq {
    /**
     * 
     * @type {string}
     * @memberof AuthEventCreateReq
     */
    'username': string;
    /**
     * 
     * @type {AuthEventType}
     * @memberof AuthEventCreateReq
     */
    'eventType': AuthEventType;
    /**
     * 
     * @type {AuthEventMethod}
     * @memberof AuthEventCreateReq
     */
    'method': AuthEventMethod;
    /**
     * 
     * @type {AuthEventStatus}
     * @memberof AuthEventCreateReq
     */
    'status': AuthEventStatus;
    /**
     * 
     * @type {ClientInformation}
     * @memberof AuthEventCreateReq
     */
    'clientInformation': ClientInformation;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthEventMethod = {
    Password: 'password',
    EmailOtp: 'email_otp',
    EmailLink: 'email_link',
    PhoneOtp: 'phone_otp',
    Passkey: 'passkey',
    SocialGithub: 'social_github',
    SocialGoogle: 'social_google',
    SocialMicrosoft: 'social_microsoft'
} as const;

export type AuthEventMethod = typeof AuthEventMethod[keyof typeof AuthEventMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthEventStatus = {
    Success: 'success',
    Failure: 'failure'
} as const;

export type AuthEventStatus = typeof AuthEventStatus[keyof typeof AuthEventStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthEventType = {
    SignUp: 'sign_up',
    Login: 'login',
    NewPasskeyAdded: 'new_passkey_added'
} as const;

export type AuthEventType = typeof AuthEventType[keyof typeof AuthEventType];


/**
 * 
 * @export
 * @interface Challenge
 */
export interface Challenge {
    /**
     * 
     * @type {string}
     * @memberof Challenge
     */
    'challengeID': string;
    /**
     * 
     * @type {ChallengeType}
     * @memberof Challenge
     */
    'type': ChallengeType;
    /**
     * 
     * @type {string}
     * @memberof Challenge
     */
    'identifierValue': string;
    /**
     * 
     * @type {string}
     * @memberof Challenge
     */
    'value': string;
    /**
     * 
     * @type {ChallengeStatus}
     * @memberof Challenge
     */
    'status': ChallengeStatus;
}


/**
 * 
 * @export
 * @interface ChallengeCreateReq
 */
export interface ChallengeCreateReq {
    /**
     * 
     * @type {ChallengeType}
     * @memberof ChallengeCreateReq
     */
    'challengeType': ChallengeType;
    /**
     * 
     * @type {string}
     * @memberof ChallengeCreateReq
     */
    'identifierValue': string;
    /**
     * 
     * @type {object}
     * @memberof ChallengeCreateReq
     */
    'challengeMetadata'?: object;
    /**
     * 
     * @type {ClientInformation}
     * @memberof ChallengeCreateReq
     */
    'clientInformation': ClientInformation;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeStatus = {
    Pending: 'pending',
    Completed: 'completed',
    Expired: 'expired'
} as const;

export type ChallengeStatus = typeof ChallengeStatus[keyof typeof ChallengeStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeType = {
    EmailOtp: 'email_otp',
    EmailLink: 'email_link',
    SmsOtp: 'sms_otp'
} as const;

export type ChallengeType = typeof ChallengeType[keyof typeof ChallengeType];


/**
 * 
 * @export
 * @interface ChallengeUpdateReq
 */
export interface ChallengeUpdateReq {
    /**
     * 
     * @type {string}
     * @memberof ChallengeUpdateReq
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ClientInformation
 */
export interface ClientInformation {
    /**
     * Client\'s IP address
     * @type {string}
     * @memberof ClientInformation
     */
    'remoteAddress': string;
    /**
     * Client\'s user agent
     * @type {string}
     * @memberof ClientInformation
     */
    'userAgent': string;
    /**
     * Client\'s environment handle
     * @type {string}
     * @memberof ClientInformation
     */
    'clientEnvHandle'?: string;
    /**
     * Client\'s fingerprint
     * @type {string}
     * @memberof ClientInformation
     */
    'javascriptFingerprint'?: string;
    /**
     * 
     * @type {JavaScriptHighEntropy}
     * @memberof ClientInformation
     */
    'javaScriptHighEntropy'?: JavaScriptHighEntropy;
    /**
     * Client\'s Bluetooth availability
     * @type {boolean}
     * @memberof ClientInformation
     */
    'bluetoothAvailable'?: boolean;
    /**
     * Client\'s password manager availability
     * @type {boolean}
     * @memberof ClientInformation
     */
    'passwordManagerAvailable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInformation
     */
    'userVerifyingPlatformAuthenticatorAvailable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientInformation
     */
    'conditionalMediationAvailable': boolean;
}
/**
 * 
 * @export
 * @interface ConnectToken
 */
export interface ConnectToken {
    /**
     * 
     * @type {string}
     * @memberof ConnectToken
     */
    'id': string;
    /**
     * 
     * @type {ConnectTokenType}
     * @memberof ConnectToken
     */
    'tokenType': ConnectTokenType;
    /**
     * 
     * @type {ConnectTokenData}
     * @memberof ConnectToken
     */
    'data': ConnectTokenData;
    /**
     * 
     * @type {ConnectTokenStatus}
     * @memberof ConnectToken
     */
    'connectTokenStatus': ConnectTokenStatus;
    /**
     * 
     * @type {string}
     * @memberof ConnectToken
     */
    'secret'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectToken
     */
    'expires': number;
}


/**
 * 
 * @export
 * @interface ConnectTokenCreateReq
 */
export interface ConnectTokenCreateReq {
    /**
     * 
     * @type {ConnectTokenType}
     * @memberof ConnectTokenCreateReq
     */
    'type': ConnectTokenType;
    /**
     * 
     * @type {ConnectTokenData}
     * @memberof ConnectTokenCreateReq
     */
    'data': ConnectTokenData;
    /**
     * 
     * @type {number}
     * @memberof ConnectTokenCreateReq
     */
    'maxLifetimeInSeconds'?: number;
}


/**
 * @type ConnectTokenData
 * @export
 */
export type ConnectTokenData = ConnectTokenDataPasskeyAppend | ConnectTokenDataPasskeyDelete | ConnectTokenDataPasskeyList;

/**
 * 
 * @export
 * @interface ConnectTokenDataPasskeyAppend
 */
export interface ConnectTokenDataPasskeyAppend {
    /**
     * 
     * @type {string}
     * @memberof ConnectTokenDataPasskeyAppend
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectTokenDataPasskeyAppend
     */
    'identifier': string;
}
/**
 * 
 * @export
 * @interface ConnectTokenDataPasskeyDelete
 */
export interface ConnectTokenDataPasskeyDelete {
    /**
     * 
     * @type {string}
     * @memberof ConnectTokenDataPasskeyDelete
     */
    'identifier': string;
}
/**
 * 
 * @export
 * @interface ConnectTokenDataPasskeyList
 */
export interface ConnectTokenDataPasskeyList {
    /**
     * 
     * @type {string}
     * @memberof ConnectTokenDataPasskeyList
     */
    'identifier': string;
}
/**
 * 
 * @export
 * @interface ConnectTokenList
 */
export interface ConnectTokenList {
    /**
     * 
     * @type {Array<ConnectToken>}
     * @memberof ConnectTokenList
     */
    'connectTokens': Array<ConnectToken>;
    /**
     * 
     * @type {Paging}
     * @memberof ConnectTokenList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectTokenStatus = {
    Initial: 'initial',
    Consumed: 'consumed'
} as const;

export type ConnectTokenStatus = typeof ConnectTokenStatus[keyof typeof ConnectTokenStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectTokenType = {
    Append: 'passkey-append',
    Delete: 'passkey-delete',
    List: 'passkey-list'
} as const;

export type ConnectTokenType = typeof ConnectTokenType[keyof typeof ConnectTokenType];


/**
 * 
 * @export
 * @interface ConnectTokenUpdateReq
 */
export interface ConnectTokenUpdateReq {
    /**
     * 
     * @type {ConnectTokenStatus}
     * @memberof ConnectTokenUpdateReq
     */
    'status': ConnectTokenStatus;
}


/**
 * 
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'credentialID': string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'attestationType': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Credential
     */
    'transport': Array<CredentialTransportEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof Credential
     */
    'backupEligible': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Credential
     */
    'backupState': boolean;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'authenticatorAAGUID': string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'sourceOS': string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'sourceBrowser': string;
    /**
     * Timestamp of when the passkey was last used in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof Credential
     */
    'lastUsed': string;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof Credential
     */
    'created': string;
    /**
     * Status
     * @type {string}
     * @memberof Credential
     */
    'status': CredentialStatusEnum;
}

export const CredentialTransportEnum = {
    Usb: 'usb',
    Nfc: 'nfc',
    Ble: 'ble',
    Internal: 'internal',
    Hybrid: 'hybrid',
    SmartCard: 'smart-card'
} as const;

export type CredentialTransportEnum = typeof CredentialTransportEnum[keyof typeof CredentialTransportEnum];
export const CredentialStatusEnum = {
    Pending: 'pending',
    Active: 'active'
} as const;

export type CredentialStatusEnum = typeof CredentialStatusEnum[keyof typeof CredentialStatusEnum];

/**
 * 
 * @export
 * @interface CredentialList
 */
export interface CredentialList {
    /**
     * 
     * @type {Array<Credential>}
     * @memberof CredentialList
     */
    'credentials': Array<Credential>;
    /**
     * 
     * @type {Paging}
     * @memberof CredentialList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CrossDeviceAuthenticationStrategy = {
    Standard: 'standard',
    Minimize: 'minimize',
    Maximize: 'maximize'
} as const;

export type CrossDeviceAuthenticationStrategy = typeof CrossDeviceAuthenticationStrategy[keyof typeof CrossDeviceAuthenticationStrategy];


/**
 * 
 * @export
 * @enum {string}
 */

export const DecisionTag = {
    EnvNoPkSupport: 'env-no-pk-support',
    UserNoPks: 'user-no-pks',
    UserLoginBlacklisted: 'user-login-blacklisted',
    UserSecurityKey: 'user-security-key',
    UserPositiveEnvHistory: 'user-positive-env-history',
    UserNegativeEnvHistory: 'user-negative-env-history',
    EnvBlacklisted: 'env-blacklisted',
    UserPlatformPkHighConfidence: 'user-platform-pk-high-confidence',
    UserCrossPlatformPkHighConfidence: 'user-cross-platform-pk-high-confidence',
    UserEnvNoPks: 'user-env-no-pks',
    DefaultDeny: 'default-deny',
    PasskeyListInitiatedProcess: 'passkey-list-initiated-process',
    UserAppendBlacklisted: 'user-append-blacklisted',
    ProcessPkLoginSkCompleted: 'process-pk-login-sk-completed',
    ProcessPkLoginPlatformCompleted: 'process-pk-login-platform-completed',
    ProcessPkLoginNotOffered: 'process-pk-login-not-offered',
    ProcessPkLoginIncomplete: 'process-pk-login-incomplete',
    ProcessPkLoginCrossPlatformCompleted: 'process-pk-login-cross-platform-completed',
    DeviceLocalPlatformPasskeyExperiment: 'device-local-platform-passkey-experiment'
} as const;

export type DecisionTag = typeof DecisionTag[keyof typeof DecisionTag];


/**
 * 
 * @export
 * @interface DetectionTag
 */
export interface DetectionTag {
    /**
     * 
     * @type {string}
     * @memberof DetectionTag
     */
    'category': DetectionTagCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof DetectionTag
     */
    'name': string;
}

export const DetectionTagCategoryEnum = {
    Support: 'support',
    ClientEnv: 'clientEnv',
    History: 'history',
    Passkey: 'passkey'
} as const;

export type DetectionTagCategoryEnum = typeof DetectionTagCategoryEnum[keyof typeof DetectionTagCategoryEnum];

/**
 * 
 * @export
 * @interface ErrorRsp
 */
export interface ErrorRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof ErrorRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof ErrorRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof ErrorRsp
     */
    'runtime': number;
    /**
     * 
     * @type {object}
     * @memberof ErrorRsp
     */
    'data'?: object;
    /**
     * 
     * @type {ErrorRspAllOfError}
     * @memberof ErrorRsp
     */
    'error': ErrorRspAllOfError;
}
/**
 * 
 * @export
 * @interface ErrorRspAllOfError
 */
export interface ErrorRspAllOfError {
    /**
     * Type of error
     * @type {string}
     * @memberof ErrorRspAllOfError
     */
    'type': string;
    /**
     * Details of error
     * @type {string}
     * @memberof ErrorRspAllOfError
     */
    'details'?: string;
    /**
     * Validation errors per field
     * @type {Array<ErrorRspAllOfErrorValidation>}
     * @memberof ErrorRspAllOfError
     */
    'validation'?: Array<ErrorRspAllOfErrorValidation>;
    /**
     * Additional links to help understand the error
     * @type {Array<string>}
     * @memberof ErrorRspAllOfError
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorRspAllOfErrorValidation
 */
export interface ErrorRspAllOfErrorValidation {
    /**
     * 
     * @type {string}
     * @memberof ErrorRspAllOfErrorValidation
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorRspAllOfErrorValidation
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GenericRsp
 */
export interface GenericRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof GenericRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof GenericRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof GenericRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof GenericRsp
     */
    'runtime': number;
}
/**
 * 
 * @export
 * @interface Identifier
 */
export interface Identifier {
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'identifierID': string;
    /**
     * 
     * @type {IdentifierType}
     * @memberof Identifier
     */
    'type': IdentifierType;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'value': string;
    /**
     * 
     * @type {IdentifierStatus}
     * @memberof Identifier
     */
    'status': IdentifierStatus;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'userID': string;
}


/**
 * 
 * @export
 * @interface IdentifierCreateReq
 */
export interface IdentifierCreateReq {
    /**
     * 
     * @type {IdentifierType}
     * @memberof IdentifierCreateReq
     */
    'identifierType': IdentifierType;
    /**
     * 
     * @type {string}
     * @memberof IdentifierCreateReq
     */
    'identifierValue': string;
    /**
     * 
     * @type {IdentifierStatus}
     * @memberof IdentifierCreateReq
     */
    'status': IdentifierStatus;
}


/**
 * 
 * @export
 * @interface IdentifierList
 */
export interface IdentifierList {
    /**
     * 
     * @type {Array<Identifier>}
     * @memberof IdentifierList
     */
    'identifiers': Array<Identifier>;
    /**
     * 
     * @type {Paging}
     * @memberof IdentifierList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IdentifierStatus = {
    Pending: 'pending',
    Primary: 'primary',
    Verified: 'verified'
} as const;

export type IdentifierStatus = typeof IdentifierStatus[keyof typeof IdentifierStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const IdentifierType = {
    Email: 'email',
    Phone: 'phone',
    Username: 'username'
} as const;

export type IdentifierType = typeof IdentifierType[keyof typeof IdentifierType];


/**
 * 
 * @export
 * @interface IdentifierUpdateReq
 */
export interface IdentifierUpdateReq {
    /**
     * 
     * @type {IdentifierStatus}
     * @memberof IdentifierUpdateReq
     */
    'status': IdentifierStatus;
}


/**
 * 
 * @export
 * @interface JavaScriptHighEntropy
 */
export interface JavaScriptHighEntropy {
    /**
     * 
     * @type {string}
     * @memberof JavaScriptHighEntropy
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof JavaScriptHighEntropy
     */
    'platformVersion': string;
    /**
     * 
     * @type {boolean}
     * @memberof JavaScriptHighEntropy
     */
    'mobile': boolean;
}
/**
 * 
 * @export
 * @interface LongSession
 */
export interface LongSession {
    /**
     * 
     * @type {string}
     * @memberof LongSession
     */
    'longSessionID': string;
    /**
     * 
     * @type {string}
     * @memberof LongSession
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof LongSession
     */
    'identifierValue': string;
    /**
     * 
     * @type {LongSessionStatus}
     * @memberof LongSession
     */
    'status': LongSessionStatus;
    /**
     * 
     * @type {string}
     * @memberof LongSession
     */
    'expires': string;
}


/**
 * 
 * @export
 * @interface LongSessionCreateReq
 */
export interface LongSessionCreateReq {
    /**
     * 
     * @type {AppType}
     * @memberof LongSessionCreateReq
     */
    'appType': AppType;
    /**
     * 
     * @type {string}
     * @memberof LongSessionCreateReq
     */
    'identifierValue': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LongSessionStatus = {
    Active: 'active',
    LoggedOut: 'logged_out',
    Expired: 'expired',
    InactivityReached: 'inactivity_reached',
    Revoked: 'revoked'
} as const;

export type LongSessionStatus = typeof LongSessionStatus[keyof typeof LongSessionStatus];


/**
 * 
 * @export
 * @interface LongSessionUpdateReq
 */
export interface LongSessionUpdateReq {
    /**
     * 
     * @type {LongSessionStatus}
     * @memberof LongSessionUpdateReq
     */
    'status': LongSessionStatus;
}


/**
 * 
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * current page returned in response
     * @type {number}
     * @memberof Paging
     */
    'page': number;
    /**
     * total number of pages available
     * @type {number}
     * @memberof Paging
     */
    'totalPages': number;
    /**
     * total number of items available
     * @type {number}
     * @memberof Paging
     */
    'totalItems': number;
}
/**
 * 
 * @export
 * @interface PasskeyAppendFinishReq
 */
export interface PasskeyAppendFinishReq {
    /**
     * ID of the user
     * @type {string}
     * @memberof PasskeyAppendFinishReq
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyAppendFinishReq
     */
    'processID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyAppendFinishReq
     */
    'attestationResponse': string;
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyAppendFinishReq
     */
    'clientInformation': ClientInformation;
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyAppendFinishReq
     */
    'sendNotification'?: boolean;
}
/**
 * 
 * @export
 * @interface PasskeyAppendFinishRsp
 */
export interface PasskeyAppendFinishRsp {
    /**
     * 
     * @type {PasskeyData}
     * @memberof PasskeyAppendFinishRsp
     */
    'passkeyData': PasskeyData;
}
/**
 * 
 * @export
 * @interface PasskeyAppendStartReq
 */
export interface PasskeyAppendStartReq {
    /**
     * ID of the user
     * @type {string}
     * @memberof PasskeyAppendStartReq
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyAppendStartReq
     */
    'processID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyAppendStartReq
     */
    'username': string;
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyAppendStartReq
     */
    'clientInformation': ClientInformation;
    /**
     * 
     * @type {PasskeyIntelFlags}
     * @memberof PasskeyAppendStartReq
     */
    'passkeyIntelFlags': PasskeyIntelFlags;
}
/**
 * 
 * @export
 * @interface PasskeyAppendStartRsp
 */
export interface PasskeyAppendStartRsp {
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyAppendStartRsp
     */
    'appendAllow': boolean;
    /**
     * 
     * @type {Array<DetectionTag>}
     * @memberof PasskeyAppendStartRsp
     */
    'detectionTags': Array<DetectionTag>;
    /**
     * 
     * @type {DecisionTag}
     * @memberof PasskeyAppendStartRsp
     */
    'decisionTag': DecisionTag;
    /**
     * 
     * @type {number}
     * @memberof PasskeyAppendStartRsp
     */
    'credentialCount': number;
    /**
     * 
     * @type {string}
     * @memberof PasskeyAppendStartRsp
     */
    'attestationOptions': string;
}


/**
 * 
 * @export
 * @interface PasskeyChallenge
 */
export interface PasskeyChallenge {
    /**
     * 
     * @type {string}
     * @memberof PasskeyChallenge
     */
    'challengeID': string;
    /**
     * 
     * @type {PasskeyChallengeType}
     * @memberof PasskeyChallenge
     */
    'type': PasskeyChallengeType;
    /**
     * 
     * @type {string}
     * @memberof PasskeyChallenge
     */
    'value': string;
    /**
     * 
     * @type {PasskeyChallengeStatus}
     * @memberof PasskeyChallenge
     */
    'status': PasskeyChallengeStatus;
    /**
     * 
     * @type {number}
     * @memberof PasskeyChallenge
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PasskeyChallenge
     */
    'expires': number;
}


/**
 * 
 * @export
 * @interface PasskeyChallengeList
 */
export interface PasskeyChallengeList {
    /**
     * 
     * @type {Array<PasskeyChallenge>}
     * @memberof PasskeyChallengeList
     */
    'passkeyChallenges': Array<PasskeyChallenge>;
    /**
     * 
     * @type {Paging}
     * @memberof PasskeyChallengeList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PasskeyChallengeStatus = {
    Pending: 'pending',
    Completed: 'completed',
    Consumed: 'consumed'
} as const;

export type PasskeyChallengeStatus = typeof PasskeyChallengeStatus[keyof typeof PasskeyChallengeStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const PasskeyChallengeType = {
    Register: 'register',
    Authenticate: 'authenticate'
} as const;

export type PasskeyChallengeType = typeof PasskeyChallengeType[keyof typeof PasskeyChallengeType];


/**
 * 
 * @export
 * @interface PasskeyChallengeUpdateReq
 */
export interface PasskeyChallengeUpdateReq {
    /**
     * 
     * @type {PasskeyChallengeStatus}
     * @memberof PasskeyChallengeUpdateReq
     */
    'status': PasskeyChallengeStatus;
}


/**
 * 
 * @export
 * @interface PasskeyData
 */
export interface PasskeyData {
    /**
     * 
     * @type {string}
     * @memberof PasskeyData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyData
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyData
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyData
     */
    'ceremonyType': PasskeyDataCeremonyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PasskeyData
     */
    'challengeID': string;
}

export const PasskeyDataCeremonyTypeEnum = {
    Local: 'local',
    Cda: 'cda',
    SecurityKey: 'security-key'
} as const;

export type PasskeyDataCeremonyTypeEnum = typeof PasskeyDataCeremonyTypeEnum[keyof typeof PasskeyDataCeremonyTypeEnum];

/**
 * 
 * @export
 * @interface PasskeyEvent
 */
export interface PasskeyEvent {
    /**
     * 
     * @type {string}
     * @memberof PasskeyEvent
     */
    'passkeyEventID': string;
    /**
     * ID of the user
     * @type {string}
     * @memberof PasskeyEvent
     */
    'userID': string;
    /**
     * 
     * @type {PasskeyEventType}
     * @memberof PasskeyEvent
     */
    'eventType': PasskeyEventType;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEvent
     */
    'clientEnvID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEvent
     */
    'processID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEvent
     */
    'credentialID'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasskeyEvent
     */
    'expires'?: number;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof PasskeyEvent
     */
    'created': string;
}


/**
 * 
 * @export
 * @interface PasskeyEventCreateReq
 */
export interface PasskeyEventCreateReq {
    /**
     * 
     * @type {PasskeyEventType}
     * @memberof PasskeyEventCreateReq
     */
    'eventType': PasskeyEventType;
    /**
     * 
     * @type {number}
     * @memberof PasskeyEventCreateReq
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEventCreateReq
     */
    'processID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEventCreateReq
     */
    'clientEnvID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyEventCreateReq
     */
    'credentialID'?: string;
}


/**
 * 
 * @export
 * @interface PasskeyEventList
 */
export interface PasskeyEventList {
    /**
     * 
     * @type {Array<PasskeyEvent>}
     * @memberof PasskeyEventList
     */
    'passkeyEvents': Array<PasskeyEvent>;
    /**
     * 
     * @type {Paging}
     * @memberof PasskeyEventList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PasskeyEventType = {
    UserLoginBlacklisted: 'user-login-blacklisted',
    LoginExplicitAbort: 'login-explicit-abort',
    LoginError: 'login-error',
    LoginOneTapSwitch: 'login-one-tap-switch',
    UserAppendAfterCrossPlatformBlacklisted: 'user-append-after-cross-platform-blacklisted',
    UserAppendAfterLoginErrorBlacklisted: 'user-append-after-login-error-blacklisted',
    AppendCredentialExists: 'append-credential-exists',
    AppendExplicitAbort: 'append-explicit-abort',
    AppendError: 'append-error'
} as const;

export type PasskeyEventType = typeof PasskeyEventType[keyof typeof PasskeyEventType];


/**
 * 
 * @export
 * @interface PasskeyIntelFlags
 */
export interface PasskeyIntelFlags {
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyIntelFlags
     */
    'forcePasskeyAppend': boolean;
}
/**
 * 
 * @export
 * @interface PasskeyLoginFinishReq
 */
export interface PasskeyLoginFinishReq {
    /**
     * ID of the user
     * @type {string}
     * @memberof PasskeyLoginFinishReq
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof PasskeyLoginFinishReq
     */
    'assertionResponse': string;
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyLoginFinishReq
     */
    'clientInformation': ClientInformation;
    /**
     * 
     * @type {string}
     * @memberof PasskeyLoginFinishReq
     */
    'processID': string;
}
/**
 * 
 * @export
 * @interface PasskeyLoginFinishRsp
 */
export interface PasskeyLoginFinishRsp {
    /**
     * 
     * @type {PasskeyData}
     * @memberof PasskeyLoginFinishRsp
     */
    'passkeyData': PasskeyData;
}
/**
 * 
 * @export
 * @interface PasskeyLoginStartReq
 */
export interface PasskeyLoginStartReq {
    /**
     * ID of the user
     * @type {string}
     * @memberof PasskeyLoginStartReq
     */
    'userID': string;
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyLoginStartReq
     */
    'clientInformation': ClientInformation;
    /**
     * 
     * @type {CrossDeviceAuthenticationStrategy}
     * @memberof PasskeyLoginStartReq
     */
    'crossDeviceAuthenticationStrategy': CrossDeviceAuthenticationStrategy;
    /**
     * 
     * @type {string}
     * @memberof PasskeyLoginStartReq
     */
    'processID': string;
}


/**
 * 
 * @export
 * @interface PasskeyLoginStartRsp
 */
export interface PasskeyLoginStartRsp {
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyLoginStartRsp
     */
    'loginAllow': boolean;
    /**
     * 
     * @type {Array<DetectionTag>}
     * @memberof PasskeyLoginStartRsp
     */
    'detectionTags': Array<DetectionTag>;
    /**
     * 
     * @type {DecisionTag}
     * @memberof PasskeyLoginStartRsp
     */
    'decisionTag': DecisionTag;
    /**
     * 
     * @type {number}
     * @memberof PasskeyLoginStartRsp
     */
    'credentialCount': number;
    /**
     * 
     * @type {string}
     * @memberof PasskeyLoginStartRsp
     */
    'assertionOptions': string;
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyLoginStartRsp
     */
    'isCDACandidate': boolean;
}


/**
 * 
 * @export
 * @interface PasskeyMediationFinishReq
 */
export interface PasskeyMediationFinishReq {
    /**
     * 
     * @type {string}
     * @memberof PasskeyMediationFinishReq
     */
    'assertionResponse': string;
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyMediationFinishReq
     */
    'clientInformation': ClientInformation;
    /**
     * 
     * @type {string}
     * @memberof PasskeyMediationFinishReq
     */
    'processID': string;
}
/**
 * 
 * @export
 * @interface PasskeyMediationFinishRsp
 */
export interface PasskeyMediationFinishRsp {
    /**
     * 
     * @type {PasskeyData}
     * @memberof PasskeyMediationFinishRsp
     */
    'passkeyData': PasskeyData;
}
/**
 * 
 * @export
 * @interface PasskeyMediationStartReq
 */
export interface PasskeyMediationStartReq {
    /**
     * 
     * @type {ClientInformation}
     * @memberof PasskeyMediationStartReq
     */
    'clientInformation': ClientInformation;
}
/**
 * 
 * @export
 * @interface PasskeyMediationStartRsp
 */
export interface PasskeyMediationStartRsp {
    /**
     * 
     * @type {boolean}
     * @memberof PasskeyMediationStartRsp
     */
    'loginAllow': boolean;
    /**
     * 
     * @type {string}
     * @memberof PasskeyMediationStartRsp
     */
    'assertionOptions': string;
}
/**
 * 
 * @export
 * @interface ProjectConfigUpdateCnameReq
 */
export interface ProjectConfigUpdateCnameReq {
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigUpdateCnameReq
     */
    'cname': string;
}
/**
 * Data about the request itself, can be used for debugging
 * @export
 * @interface RequestData
 */
export interface RequestData {
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof RequestData
     */
    'requestID': string;
    /**
     * Link to dashboard with details about request
     * @type {string}
     * @memberof RequestData
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface ShortSession
 */
export interface ShortSession {
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ShortSessionCreateReq
 */
export interface ShortSessionCreateReq {
    /**
     * 
     * @type {AppType}
     * @memberof ShortSessionCreateReq
     */
    'appType': AppType;
    /**
     * 
     * @type {string}
     * @memberof ShortSessionCreateReq
     */
    'issuer': string;
}


/**
 * 
 * @export
 * @interface SocialAccount
 */
export interface SocialAccount {
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'socialAccountID': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'providerType': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'identifierValue': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'foreignID': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'avatarURL': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccount
     */
    'fullName': string;
}
/**
 * 
 * @export
 * @interface SocialAccountCreateReq
 */
export interface SocialAccountCreateReq {
    /**
     * 
     * @type {SocialProviderType}
     * @memberof SocialAccountCreateReq
     */
    'providerType': SocialProviderType;
    /**
     * 
     * @type {string}
     * @memberof SocialAccountCreateReq
     */
    'identifierValue': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccountCreateReq
     */
    'foreignID': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccountCreateReq
     */
    'avatarURL': string;
    /**
     * 
     * @type {string}
     * @memberof SocialAccountCreateReq
     */
    'fullName': string;
}


/**
 * 
 * @export
 * @interface SocialAccountList
 */
export interface SocialAccountList {
    /**
     * 
     * @type {Array<SocialAccount>}
     * @memberof SocialAccountList
     */
    'socialAccounts': Array<SocialAccount>;
    /**
     * 
     * @type {Paging}
     * @memberof SocialAccountList
     */
    'paging': Paging;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SocialProviderType = {
    Google: 'google',
    Microsoft: 'microsoft',
    Github: 'github'
} as const;

export type SocialProviderType = typeof SocialProviderType[keyof typeof SocialProviderType];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    'status': UserStatus;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'explicitWebauthnID'?: string;
}


/**
 * 
 * @export
 * @interface UserCreateReq
 */
export interface UserCreateReq {
    /**
     * 
     * @type {string}
     * @memberof UserCreateReq
     */
    'fullName'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof UserCreateReq
     */
    'status': UserStatus;
    /**
     * For connect projects, the webauthnID can be explicitly set for a user
     * @type {string}
     * @memberof UserCreateReq
     */
    'explicitWebauthnID'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Pending: 'pending',
    Active: 'active',
    Disabled: 'disabled'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 
 * @export
 * @interface UserUpdateReq
 */
export interface UserUpdateReq {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateReq
     */
    'fullName'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof UserUpdateReq
     */
    'status'?: UserStatus;
}



/**
 * AuthEventsApi - axios parameter creator
 * @export
 */
export const AuthEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new authentication event for a user
         * @param {string} userID ID of user
         * @param {AuthEventCreateReq} authEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEventCreate: async (userID: string, authEventCreateReq: AuthEventCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('authEventCreate', 'userID', userID)
            // verify required parameter 'authEventCreateReq' is not null or undefined
            assertParamExists('authEventCreate', 'authEventCreateReq', authEventCreateReq)
            const localVarPath = `/users/{userID}/authEvents`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authEventCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthEventsApi - functional programming interface
 * @export
 */
export const AuthEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new authentication event for a user
         * @param {string} userID ID of user
         * @param {AuthEventCreateReq} authEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEventCreate(userID: string, authEventCreateReq: AuthEventCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEventCreate(userID, authEventCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthEventsApi.authEventCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthEventsApi - factory interface
 * @export
 */
export const AuthEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthEventsApiFp(configuration)
    return {
        /**
         * Create a new authentication event for a user
         * @param {string} userID ID of user
         * @param {AuthEventCreateReq} authEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEventCreate(userID: string, authEventCreateReq: AuthEventCreateReq, options?: any): AxiosPromise<AuthEvent> {
            return localVarFp.authEventCreate(userID, authEventCreateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthEventsApi - object-oriented interface
 * @export
 * @class AuthEventsApi
 * @extends {BaseAPI}
 */
export class AuthEventsApi extends BaseAPI {
    /**
     * Create a new authentication event for a user
     * @param {string} userID ID of user
     * @param {AuthEventCreateReq} authEventCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthEventsApi
     */
    public authEventCreate(userID: string, authEventCreateReq: AuthEventCreateReq, options?: AxiosRequestConfig) {
        return AuthEventsApiFp(this.configuration).authEventCreate(userID, authEventCreateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChallengesApi - axios parameter creator
 * @export
 */
export const ChallengesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new challenge to verify a login identifier
         * @param {string} userID ID of user
         * @param {ChallengeCreateReq} challengeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengeCreate: async (userID: string, challengeCreateReq: ChallengeCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('challengeCreate', 'userID', userID)
            // verify required parameter 'challengeCreateReq' is not null or undefined
            assertParamExists('challengeCreate', 'challengeCreateReq', challengeCreateReq)
            const localVarPath = `/users/{userID}/challenges`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(challengeCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a challenge (e.g. from pending to completed)
         * @param {string} userID ID of user
         * @param {string} challengeID ID of challenge
         * @param {ChallengeUpdateReq} challengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengeUpdate: async (userID: string, challengeID: string, challengeUpdateReq: ChallengeUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('challengeUpdate', 'userID', userID)
            // verify required parameter 'challengeID' is not null or undefined
            assertParamExists('challengeUpdate', 'challengeID', challengeID)
            // verify required parameter 'challengeUpdateReq' is not null or undefined
            assertParamExists('challengeUpdate', 'challengeUpdateReq', challengeUpdateReq)
            const localVarPath = `/users/{userID}/challenges/{challengeID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"challengeID"}}`, encodeURIComponent(String(challengeID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(challengeUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengesApi - functional programming interface
 * @export
 */
export const ChallengesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChallengesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new challenge to verify a login identifier
         * @param {string} userID ID of user
         * @param {ChallengeCreateReq} challengeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengeCreate(userID: string, challengeCreateReq: ChallengeCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Challenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengeCreate(userID, challengeCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChallengesApi.challengeCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates a challenge (e.g. from pending to completed)
         * @param {string} userID ID of user
         * @param {string} challengeID ID of challenge
         * @param {ChallengeUpdateReq} challengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengeUpdate(userID: string, challengeID: string, challengeUpdateReq: ChallengeUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Challenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengeUpdate(userID, challengeID, challengeUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChallengesApi.challengeUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ChallengesApi - factory interface
 * @export
 */
export const ChallengesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChallengesApiFp(configuration)
    return {
        /**
         * Create a new challenge to verify a login identifier
         * @param {string} userID ID of user
         * @param {ChallengeCreateReq} challengeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengeCreate(userID: string, challengeCreateReq: ChallengeCreateReq, options?: any): AxiosPromise<Challenge> {
            return localVarFp.challengeCreate(userID, challengeCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a challenge (e.g. from pending to completed)
         * @param {string} userID ID of user
         * @param {string} challengeID ID of challenge
         * @param {ChallengeUpdateReq} challengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengeUpdate(userID: string, challengeID: string, challengeUpdateReq: ChallengeUpdateReq, options?: any): AxiosPromise<Challenge> {
            return localVarFp.challengeUpdate(userID, challengeID, challengeUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChallengesApi - object-oriented interface
 * @export
 * @class ChallengesApi
 * @extends {BaseAPI}
 */
export class ChallengesApi extends BaseAPI {
    /**
     * Create a new challenge to verify a login identifier
     * @param {string} userID ID of user
     * @param {ChallengeCreateReq} challengeCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public challengeCreate(userID: string, challengeCreateReq: ChallengeCreateReq, options?: AxiosRequestConfig) {
        return ChallengesApiFp(this.configuration).challengeCreate(userID, challengeCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a challenge (e.g. from pending to completed)
     * @param {string} userID ID of user
     * @param {string} challengeID ID of challenge
     * @param {ChallengeUpdateReq} challengeUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengesApi
     */
    public challengeUpdate(userID: string, challengeID: string, challengeUpdateReq: ChallengeUpdateReq, options?: AxiosRequestConfig) {
        return ChallengesApiFp(this.configuration).challengeUpdate(userID, challengeID, challengeUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectTokensApi - axios parameter creator
 * @export
 */
export const ConnectTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new connect token
         * @param {ConnectTokenCreateReq} connectTokenCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenCreate: async (connectTokenCreateReq: ConnectTokenCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectTokenCreateReq' is not null or undefined
            assertParamExists('connectTokenCreate', 'connectTokenCreateReq', connectTokenCreateReq)
            const localVarPath = `/connectTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectTokenCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenDelete: async (connectTokenID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectTokenID' is not null or undefined
            assertParamExists('connectTokenDelete', 'connectTokenID', connectTokenID)
            const localVarPath = `/connectTokens/{connectTokenID}`
                .replace(`{${"connectTokenID"}}`, encodeURIComponent(String(connectTokenID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of matching append tokens
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenList: async (sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {ConnectTokenUpdateReq} connectTokenUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenUpdate: async (connectTokenID: string, connectTokenUpdateReq: ConnectTokenUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectTokenID' is not null or undefined
            assertParamExists('connectTokenUpdate', 'connectTokenID', connectTokenID)
            // verify required parameter 'connectTokenUpdateReq' is not null or undefined
            assertParamExists('connectTokenUpdate', 'connectTokenUpdateReq', connectTokenUpdateReq)
            const localVarPath = `/connectTokens/{connectTokenID}`
                .replace(`{${"connectTokenID"}}`, encodeURIComponent(String(connectTokenID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectTokenUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectTokensApi - functional programming interface
 * @export
 */
export const ConnectTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new connect token
         * @param {ConnectTokenCreateReq} connectTokenCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectTokenCreate(connectTokenCreateReq: ConnectTokenCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectTokenCreate(connectTokenCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectTokensApi.connectTokenCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectTokenDelete(connectTokenID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectTokenDelete(connectTokenID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectTokensApi.connectTokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of matching append tokens
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectTokenList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectTokenList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectTokenList(sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectTokensApi.connectTokenList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {ConnectTokenUpdateReq} connectTokenUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectTokenUpdate(connectTokenID: string, connectTokenUpdateReq: ConnectTokenUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectTokenUpdate(connectTokenID, connectTokenUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectTokensApi.connectTokenUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConnectTokensApi - factory interface
 * @export
 */
export const ConnectTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectTokensApiFp(configuration)
    return {
        /**
         * Create a new connect token
         * @param {ConnectTokenCreateReq} connectTokenCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenCreate(connectTokenCreateReq: ConnectTokenCreateReq, options?: any): AxiosPromise<ConnectToken> {
            return localVarFp.connectTokenCreate(connectTokenCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenDelete(connectTokenID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.connectTokenDelete(connectTokenID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of matching append tokens
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<ConnectTokenList> {
            return localVarFp.connectTokenList(sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing append token
         * @param {string} connectTokenID ID of an append token
         * @param {ConnectTokenUpdateReq} connectTokenUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectTokenUpdate(connectTokenID: string, connectTokenUpdateReq: ConnectTokenUpdateReq, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.connectTokenUpdate(connectTokenID, connectTokenUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectTokensApi - object-oriented interface
 * @export
 * @class ConnectTokensApi
 * @extends {BaseAPI}
 */
export class ConnectTokensApi extends BaseAPI {
    /**
     * Create a new connect token
     * @param {ConnectTokenCreateReq} connectTokenCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectTokensApi
     */
    public connectTokenCreate(connectTokenCreateReq: ConnectTokenCreateReq, options?: AxiosRequestConfig) {
        return ConnectTokensApiFp(this.configuration).connectTokenCreate(connectTokenCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing append token
     * @param {string} connectTokenID ID of an append token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectTokensApi
     */
    public connectTokenDelete(connectTokenID: string, options?: AxiosRequestConfig) {
        return ConnectTokensApiFp(this.configuration).connectTokenDelete(connectTokenID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of matching append tokens
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectTokensApi
     */
    public connectTokenList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return ConnectTokensApiFp(this.configuration).connectTokenList(sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing append token
     * @param {string} connectTokenID ID of an append token
     * @param {ConnectTokenUpdateReq} connectTokenUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectTokensApi
     */
    public connectTokenUpdate(connectTokenID: string, connectTokenUpdateReq: ConnectTokenUpdateReq, options?: AxiosRequestConfig) {
        return ConnectTokensApiFp(this.configuration).connectTokenUpdate(connectTokenID, connectTokenUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentifiersApi - axios parameter creator
 * @export
 */
export const IdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new login identifier
         * @param {string} userID ID of user
         * @param {IdentifierCreateReq} identifierCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierCreate: async (userID: string, identifierCreateReq: IdentifierCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('identifierCreate', 'userID', userID)
            // verify required parameter 'identifierCreateReq' is not null or undefined
            assertParamExists('identifierCreate', 'identifierCreateReq', identifierCreateReq)
            const localVarPath = `/users/{userID}/identifiers`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing login identifier
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierDelete: async (userID: string, identifierID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('identifierDelete', 'userID', userID)
            // verify required parameter 'identifierID' is not null or undefined
            assertParamExists('identifierDelete', 'identifierID', identifierID)
            const localVarPath = `/users/{userID}/identifiers/{identifierID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"identifierID"}}`, encodeURIComponent(String(identifierID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of matching identifiers
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierList: async (sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a login identifier (e.g. from pending to verified)
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {IdentifierUpdateReq} identifierUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierUpdate: async (userID: string, identifierID: string, identifierUpdateReq: IdentifierUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('identifierUpdate', 'userID', userID)
            // verify required parameter 'identifierID' is not null or undefined
            assertParamExists('identifierUpdate', 'identifierID', identifierID)
            // verify required parameter 'identifierUpdateReq' is not null or undefined
            assertParamExists('identifierUpdate', 'identifierUpdateReq', identifierUpdateReq)
            const localVarPath = `/users/{userID}/identifiers/{identifierID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"identifierID"}}`, encodeURIComponent(String(identifierID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentifiersApi - functional programming interface
 * @export
 */
export const IdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new login identifier
         * @param {string} userID ID of user
         * @param {IdentifierCreateReq} identifierCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierCreate(userID: string, identifierCreateReq: IdentifierCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierCreate(userID, identifierCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentifiersApi.identifierCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete an existing login identifier
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierDelete(userID: string, identifierID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierDelete(userID, identifierID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentifiersApi.identifierDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of matching identifiers
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierList(sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentifiersApi.identifierList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates a login identifier (e.g. from pending to verified)
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {IdentifierUpdateReq} identifierUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierUpdate(userID: string, identifierID: string, identifierUpdateReq: IdentifierUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierUpdate(userID, identifierID, identifierUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IdentifiersApi.identifierUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * IdentifiersApi - factory interface
 * @export
 */
export const IdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentifiersApiFp(configuration)
    return {
        /**
         * Create a new login identifier
         * @param {string} userID ID of user
         * @param {IdentifierCreateReq} identifierCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierCreate(userID: string, identifierCreateReq: IdentifierCreateReq, options?: any): AxiosPromise<Identifier> {
            return localVarFp.identifierCreate(userID, identifierCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing login identifier
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierDelete(userID: string, identifierID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.identifierDelete(userID, identifierID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of matching identifiers
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<IdentifierList> {
            return localVarFp.identifierList(sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a login identifier (e.g. from pending to verified)
         * @param {string} userID ID of user
         * @param {string} identifierID ID of login identifier
         * @param {IdentifierUpdateReq} identifierUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierUpdate(userID: string, identifierID: string, identifierUpdateReq: IdentifierUpdateReq, options?: any): AxiosPromise<Identifier> {
            return localVarFp.identifierUpdate(userID, identifierID, identifierUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentifiersApi - object-oriented interface
 * @export
 * @class IdentifiersApi
 * @extends {BaseAPI}
 */
export class IdentifiersApi extends BaseAPI {
    /**
     * Create a new login identifier
     * @param {string} userID ID of user
     * @param {IdentifierCreateReq} identifierCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifierCreate(userID: string, identifierCreateReq: IdentifierCreateReq, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifierCreate(userID, identifierCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing login identifier
     * @param {string} userID ID of user
     * @param {string} identifierID ID of login identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifierDelete(userID: string, identifierID: string, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifierDelete(userID, identifierID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of matching identifiers
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifierList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifierList(sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a login identifier (e.g. from pending to verified)
     * @param {string} userID ID of user
     * @param {string} identifierID ID of login identifier
     * @param {IdentifierUpdateReq} identifierUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifierUpdate(userID: string, identifierID: string, identifierUpdateReq: IdentifierUpdateReq, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifierUpdate(userID, identifierID, identifierUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasskeyChallengesApi - axios parameter creator
 * @export
 */
export const PasskeyChallengesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of matching passkey challenges
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyChallengeList: async (userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('passkeyChallengeList', 'userID', userID)
            const localVarPath = `/users/{userID}/passkeyChallenges`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a passkey challenge
         * @param {string} userID ID of user
         * @param {string} passkeyChallengeID ID of a passkey challenge
         * @param {PasskeyChallengeUpdateReq} passkeyChallengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyChallengeUpdate: async (userID: string, passkeyChallengeID: string, passkeyChallengeUpdateReq: PasskeyChallengeUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('passkeyChallengeUpdate', 'userID', userID)
            // verify required parameter 'passkeyChallengeID' is not null or undefined
            assertParamExists('passkeyChallengeUpdate', 'passkeyChallengeID', passkeyChallengeID)
            // verify required parameter 'passkeyChallengeUpdateReq' is not null or undefined
            assertParamExists('passkeyChallengeUpdate', 'passkeyChallengeUpdateReq', passkeyChallengeUpdateReq)
            const localVarPath = `/users/{userID}/passkeyChallenges/{passkeyChallengeID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"passkeyChallengeID"}}`, encodeURIComponent(String(passkeyChallengeID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyChallengeUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasskeyChallengesApi - functional programming interface
 * @export
 */
export const PasskeyChallengesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasskeyChallengesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of matching passkey challenges
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyChallengeList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyChallengeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyChallengeList(userID, sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeyChallengesApi.passkeyChallengeList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates a passkey challenge
         * @param {string} userID ID of user
         * @param {string} passkeyChallengeID ID of a passkey challenge
         * @param {PasskeyChallengeUpdateReq} passkeyChallengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyChallengeUpdate(userID: string, passkeyChallengeID: string, passkeyChallengeUpdateReq: PasskeyChallengeUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyChallengeUpdate(userID, passkeyChallengeID, passkeyChallengeUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeyChallengesApi.passkeyChallengeUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasskeyChallengesApi - factory interface
 * @export
 */
export const PasskeyChallengesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasskeyChallengesApiFp(configuration)
    return {
        /**
         * Returns a list of matching passkey challenges
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyChallengeList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<PasskeyChallengeList> {
            return localVarFp.passkeyChallengeList(userID, sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a passkey challenge
         * @param {string} userID ID of user
         * @param {string} passkeyChallengeID ID of a passkey challenge
         * @param {PasskeyChallengeUpdateReq} passkeyChallengeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyChallengeUpdate(userID: string, passkeyChallengeID: string, passkeyChallengeUpdateReq: PasskeyChallengeUpdateReq, options?: any): AxiosPromise<PasskeyChallenge> {
            return localVarFp.passkeyChallengeUpdate(userID, passkeyChallengeID, passkeyChallengeUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasskeyChallengesApi - object-oriented interface
 * @export
 * @class PasskeyChallengesApi
 * @extends {BaseAPI}
 */
export class PasskeyChallengesApi extends BaseAPI {
    /**
     * Returns a list of matching passkey challenges
     * @param {string} userID ID of user
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeyChallengesApi
     */
    public passkeyChallengeList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return PasskeyChallengesApiFp(this.configuration).passkeyChallengeList(userID, sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a passkey challenge
     * @param {string} userID ID of user
     * @param {string} passkeyChallengeID ID of a passkey challenge
     * @param {PasskeyChallengeUpdateReq} passkeyChallengeUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeyChallengesApi
     */
    public passkeyChallengeUpdate(userID: string, passkeyChallengeID: string, passkeyChallengeUpdateReq: PasskeyChallengeUpdateReq, options?: AxiosRequestConfig) {
        return PasskeyChallengesApiFp(this.configuration).passkeyChallengeUpdate(userID, passkeyChallengeID, passkeyChallengeUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasskeyEventsApi - axios parameter creator
 * @export
 */
export const PasskeyEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new passkey event for a user
         * @param {string} userID ID of user
         * @param {PasskeyEventCreateReq} passkeyEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventCreate: async (userID: string, passkeyEventCreateReq: PasskeyEventCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('passkeyEventCreate', 'userID', userID)
            // verify required parameter 'passkeyEventCreateReq' is not null or undefined
            assertParamExists('passkeyEventCreate', 'passkeyEventCreateReq', passkeyEventCreateReq)
            const localVarPath = `/users/{userID}/passkeyEvents`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyEventCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing passkey event
         * @param {string} userID ID of user
         * @param {string} passkeyEventID ID of a passkey event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventDelete: async (userID: string, passkeyEventID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('passkeyEventDelete', 'userID', userID)
            // verify required parameter 'passkeyEventID' is not null or undefined
            assertParamExists('passkeyEventDelete', 'passkeyEventID', passkeyEventID)
            const localVarPath = `/users/{userID}/passkeyEvents/{passkeyEventID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"passkeyEventID"}}`, encodeURIComponent(String(passkeyEventID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of matching passkey events
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventList: async (userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('passkeyEventList', 'userID', userID)
            const localVarPath = `/users/{userID}/passkeyEvents`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasskeyEventsApi - functional programming interface
 * @export
 */
export const PasskeyEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasskeyEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new passkey event for a user
         * @param {string} userID ID of user
         * @param {PasskeyEventCreateReq} passkeyEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyEventCreate(userID: string, passkeyEventCreateReq: PasskeyEventCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyEventCreate(userID, passkeyEventCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeyEventsApi.passkeyEventCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes an existing passkey event
         * @param {string} userID ID of user
         * @param {string} passkeyEventID ID of a passkey event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyEventDelete(userID: string, passkeyEventID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyEventDelete(userID, passkeyEventID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeyEventsApi.passkeyEventDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of matching passkey events
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyEventList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyEventList(userID, sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeyEventsApi.passkeyEventList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasskeyEventsApi - factory interface
 * @export
 */
export const PasskeyEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasskeyEventsApiFp(configuration)
    return {
        /**
         * Create a new passkey event for a user
         * @param {string} userID ID of user
         * @param {PasskeyEventCreateReq} passkeyEventCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventCreate(userID: string, passkeyEventCreateReq: PasskeyEventCreateReq, options?: any): AxiosPromise<PasskeyEvent> {
            return localVarFp.passkeyEventCreate(userID, passkeyEventCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing passkey event
         * @param {string} userID ID of user
         * @param {string} passkeyEventID ID of a passkey event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventDelete(userID: string, passkeyEventID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.passkeyEventDelete(userID, passkeyEventID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of matching passkey events
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyEventList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<PasskeyEventList> {
            return localVarFp.passkeyEventList(userID, sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasskeyEventsApi - object-oriented interface
 * @export
 * @class PasskeyEventsApi
 * @extends {BaseAPI}
 */
export class PasskeyEventsApi extends BaseAPI {
    /**
     * Create a new passkey event for a user
     * @param {string} userID ID of user
     * @param {PasskeyEventCreateReq} passkeyEventCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeyEventsApi
     */
    public passkeyEventCreate(userID: string, passkeyEventCreateReq: PasskeyEventCreateReq, options?: AxiosRequestConfig) {
        return PasskeyEventsApiFp(this.configuration).passkeyEventCreate(userID, passkeyEventCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing passkey event
     * @param {string} userID ID of user
     * @param {string} passkeyEventID ID of a passkey event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeyEventsApi
     */
    public passkeyEventDelete(userID: string, passkeyEventID: string, options?: AxiosRequestConfig) {
        return PasskeyEventsApiFp(this.configuration).passkeyEventDelete(userID, passkeyEventID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of matching passkey events
     * @param {string} userID ID of user
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeyEventsApi
     */
    public passkeyEventList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return PasskeyEventsApiFp(this.configuration).passkeyEventList(userID, sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasskeysApi - axios parameter creator
 * @export
 */
export const PasskeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes a challenge for creating a new passkey
         * @param {PasskeyAppendFinishReq} passkeyAppendFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyAppendFinish: async (passkeyAppendFinishReq: PasskeyAppendFinishReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyAppendFinishReq' is not null or undefined
            assertParamExists('passkeyAppendFinish', 'passkeyAppendFinishReq', passkeyAppendFinishReq)
            const localVarPath = `/passkey/append/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyAppendFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a challenge for creating a new passkey
         * @param {PasskeyAppendStartReq} passkeyAppendStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyAppendStart: async (passkeyAppendStartReq: PasskeyAppendStartReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyAppendStartReq' is not null or undefined
            assertParamExists('passkeyAppendStart', 'passkeyAppendStartReq', passkeyAppendStartReq)
            const localVarPath = `/passkey/append/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyAppendStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a challenge for an existing passkey
         * @param {PasskeyLoginFinishReq} passkeyLoginFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginFinish: async (passkeyLoginFinishReq: PasskeyLoginFinishReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyLoginFinishReq' is not null or undefined
            assertParamExists('passkeyLoginFinish', 'passkeyLoginFinishReq', passkeyLoginFinishReq)
            const localVarPath = `/passkey/login/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyLoginFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a challenge for an existing passkey
         * @param {PasskeyLoginStartReq} passkeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginStart: async (passkeyLoginStartReq: PasskeyLoginStartReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyLoginStartReq' is not null or undefined
            assertParamExists('passkeyLoginStart', 'passkeyLoginStartReq', passkeyLoginStartReq)
            const localVarPath = `/passkey/login/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyLoginStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationFinishReq} passkeyMediationFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyMediationFinish: async (passkeyMediationFinishReq: PasskeyMediationFinishReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyMediationFinishReq' is not null or undefined
            assertParamExists('passkeyMediationFinish', 'passkeyMediationFinishReq', passkeyMediationFinishReq)
            const localVarPath = `/passkey/mediation/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyMediationFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationStartReq} passkeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyMediationStart: async (passkeyMediationStartReq: PasskeyMediationStartReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyMediationStartReq' is not null or undefined
            assertParamExists('passkeyMediationStart', 'passkeyMediationStartReq', passkeyMediationStartReq)
            const localVarPath = `/passkey/mediation/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyMediationStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasskeysApi - functional programming interface
 * @export
 */
export const PasskeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasskeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes a challenge for creating a new passkey
         * @param {PasskeyAppendFinishReq} passkeyAppendFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyAppendFinish(passkeyAppendFinishReq: PasskeyAppendFinishReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyAppendFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyAppendFinish(passkeyAppendFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyAppendFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Starts a challenge for creating a new passkey
         * @param {PasskeyAppendStartReq} passkeyAppendStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyAppendStart(passkeyAppendStartReq: PasskeyAppendStartReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyAppendStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyAppendStart(passkeyAppendStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyAppendStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Completes a challenge for an existing passkey
         * @param {PasskeyLoginFinishReq} passkeyLoginFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyLoginFinish(passkeyLoginFinishReq: PasskeyLoginFinishReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyLoginFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyLoginFinish(passkeyLoginFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyLoginFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Starts a challenge for an existing passkey
         * @param {PasskeyLoginStartReq} passkeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyLoginStart(passkeyLoginStartReq: PasskeyLoginStartReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyLoginStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyLoginStart(passkeyLoginStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyLoginStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Completes a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationFinishReq} passkeyMediationFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyMediationFinish(passkeyMediationFinishReq: PasskeyMediationFinishReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyMediationFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyMediationFinish(passkeyMediationFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyMediationFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Starts a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationStartReq} passkeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyMediationStart(passkeyMediationStartReq: PasskeyMediationStartReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyMediationStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyMediationStart(passkeyMediationStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PasskeysApi.passkeyMediationStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PasskeysApi - factory interface
 * @export
 */
export const PasskeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasskeysApiFp(configuration)
    return {
        /**
         * Completes a challenge for creating a new passkey
         * @param {PasskeyAppendFinishReq} passkeyAppendFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyAppendFinish(passkeyAppendFinishReq: PasskeyAppendFinishReq, options?: any): AxiosPromise<PasskeyAppendFinishRsp> {
            return localVarFp.passkeyAppendFinish(passkeyAppendFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a challenge for creating a new passkey
         * @param {PasskeyAppendStartReq} passkeyAppendStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyAppendStart(passkeyAppendStartReq: PasskeyAppendStartReq, options?: any): AxiosPromise<PasskeyAppendStartRsp> {
            return localVarFp.passkeyAppendStart(passkeyAppendStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a challenge for an existing passkey
         * @param {PasskeyLoginFinishReq} passkeyLoginFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginFinish(passkeyLoginFinishReq: PasskeyLoginFinishReq, options?: any): AxiosPromise<PasskeyLoginFinishRsp> {
            return localVarFp.passkeyLoginFinish(passkeyLoginFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a challenge for an existing passkey
         * @param {PasskeyLoginStartReq} passkeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginStart(passkeyLoginStartReq: PasskeyLoginStartReq, options?: any): AxiosPromise<PasskeyLoginStartRsp> {
            return localVarFp.passkeyLoginStart(passkeyLoginStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationFinishReq} passkeyMediationFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyMediationFinish(passkeyMediationFinishReq: PasskeyMediationFinishReq, options?: any): AxiosPromise<PasskeyMediationFinishRsp> {
            return localVarFp.passkeyMediationFinish(passkeyMediationFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a challenge for an existing passkey (Conditional UI)
         * @param {PasskeyMediationStartReq} passkeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyMediationStart(passkeyMediationStartReq: PasskeyMediationStartReq, options?: any): AxiosPromise<PasskeyMediationStartRsp> {
            return localVarFp.passkeyMediationStart(passkeyMediationStartReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasskeysApi - object-oriented interface
 * @export
 * @class PasskeysApi
 * @extends {BaseAPI}
 */
export class PasskeysApi extends BaseAPI {
    /**
     * Completes a challenge for creating a new passkey
     * @param {PasskeyAppendFinishReq} passkeyAppendFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyAppendFinish(passkeyAppendFinishReq: PasskeyAppendFinishReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyAppendFinish(passkeyAppendFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a challenge for creating a new passkey
     * @param {PasskeyAppendStartReq} passkeyAppendStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyAppendStart(passkeyAppendStartReq: PasskeyAppendStartReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyAppendStart(passkeyAppendStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a challenge for an existing passkey
     * @param {PasskeyLoginFinishReq} passkeyLoginFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyLoginFinish(passkeyLoginFinishReq: PasskeyLoginFinishReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyLoginFinish(passkeyLoginFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a challenge for an existing passkey
     * @param {PasskeyLoginStartReq} passkeyLoginStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyLoginStart(passkeyLoginStartReq: PasskeyLoginStartReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyLoginStart(passkeyLoginStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a challenge for an existing passkey (Conditional UI)
     * @param {PasskeyMediationFinishReq} passkeyMediationFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyMediationFinish(passkeyMediationFinishReq: PasskeyMediationFinishReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyMediationFinish(passkeyMediationFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a challenge for an existing passkey (Conditional UI)
     * @param {PasskeyMediationStartReq} passkeyMediationStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasskeysApi
     */
    public passkeyMediationStart(passkeyMediationStartReq: PasskeyMediationStartReq, options?: AxiosRequestConfig) {
        return PasskeysApiFp(this.configuration).passkeyMediationStart(passkeyMediationStartReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectConfigApi - axios parameter creator
 * @export
 */
export const ProjectConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update project config CNAME and generates new SSL certificate
         * @param {ProjectConfigUpdateCnameReq} projectConfigUpdateCnameReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfigUpdateCNAME: async (projectConfigUpdateCnameReq: ProjectConfigUpdateCnameReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectConfigUpdateCnameReq' is not null or undefined
            assertParamExists('projectConfigUpdateCNAME', 'projectConfigUpdateCnameReq', projectConfigUpdateCnameReq)
            const localVarPath = `/projectConfig/cname`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectConfigUpdateCnameReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectConfigApi - functional programming interface
 * @export
 */
export const ProjectConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Update project config CNAME and generates new SSL certificate
         * @param {ProjectConfigUpdateCnameReq} projectConfigUpdateCnameReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectConfigUpdateCNAME(projectConfigUpdateCnameReq: ProjectConfigUpdateCnameReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectConfigUpdateCNAME(projectConfigUpdateCnameReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectConfigApi.projectConfigUpdateCNAME']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProjectConfigApi - factory interface
 * @export
 */
export const ProjectConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectConfigApiFp(configuration)
    return {
        /**
         * Update project config CNAME and generates new SSL certificate
         * @param {ProjectConfigUpdateCnameReq} projectConfigUpdateCnameReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfigUpdateCNAME(projectConfigUpdateCnameReq: ProjectConfigUpdateCnameReq, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.projectConfigUpdateCNAME(projectConfigUpdateCnameReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectConfigApi - object-oriented interface
 * @export
 * @class ProjectConfigApi
 * @extends {BaseAPI}
 */
export class ProjectConfigApi extends BaseAPI {
    /**
     * Update project config CNAME and generates new SSL certificate
     * @param {ProjectConfigUpdateCnameReq} projectConfigUpdateCnameReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigApi
     */
    public projectConfigUpdateCNAME(projectConfigUpdateCnameReq: ProjectConfigUpdateCnameReq, options?: AxiosRequestConfig) {
        return ProjectConfigApiFp(this.configuration).projectConfigUpdateCNAME(projectConfigUpdateCnameReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new long session
         * @param {string} userID ID of user
         * @param {LongSessionCreateReq} longSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionCreate: async (userID: string, longSessionCreateReq: LongSessionCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('longSessionCreate', 'userID', userID)
            // verify required parameter 'longSessionCreateReq' is not null or undefined
            assertParamExists('longSessionCreate', 'longSessionCreateReq', longSessionCreateReq)
            const localVarPath = `/users/{userID}/longSessions`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(longSessionCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a long session by ID
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionGet: async (longSessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longSessionID' is not null or undefined
            assertParamExists('longSessionGet', 'longSessionID', longSessionID)
            const localVarPath = `/longSessions/{longSessionID}`
                .replace(`{${"longSessionID"}}`, encodeURIComponent(String(longSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates long session status
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {LongSessionUpdateReq} longSessionUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionUpdate: async (userID: string, longSessionID: string, longSessionUpdateReq: LongSessionUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('longSessionUpdate', 'userID', userID)
            // verify required parameter 'longSessionID' is not null or undefined
            assertParamExists('longSessionUpdate', 'longSessionID', longSessionID)
            // verify required parameter 'longSessionUpdateReq' is not null or undefined
            assertParamExists('longSessionUpdate', 'longSessionUpdateReq', longSessionUpdateReq)
            const localVarPath = `/users/{userID}/longSessions/{longSessionID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"longSessionID"}}`, encodeURIComponent(String(longSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(longSessionUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new short session
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {ShortSessionCreateReq} shortSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortSessionCreate: async (userID: string, longSessionID: string, shortSessionCreateReq: ShortSessionCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('shortSessionCreate', 'userID', userID)
            // verify required parameter 'longSessionID' is not null or undefined
            assertParamExists('shortSessionCreate', 'longSessionID', longSessionID)
            // verify required parameter 'shortSessionCreateReq' is not null or undefined
            assertParamExists('shortSessionCreate', 'shortSessionCreateReq', shortSessionCreateReq)
            const localVarPath = `/users/{userID}/longSessions/{longSessionID}/shortSessions`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"longSessionID"}}`, encodeURIComponent(String(longSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shortSessionCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a long session by ID and user ID
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLongSessionGet: async (userID: string, longSessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('userLongSessionGet', 'userID', userID)
            // verify required parameter 'longSessionID' is not null or undefined
            assertParamExists('userLongSessionGet', 'longSessionID', longSessionID)
            const localVarPath = `/users/{userID}/longSessions/{longSessionID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"longSessionID"}}`, encodeURIComponent(String(longSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new long session
         * @param {string} userID ID of user
         * @param {LongSessionCreateReq} longSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async longSessionCreate(userID: string, longSessionCreateReq: LongSessionCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.longSessionCreate(userID, longSessionCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.longSessionCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a long session by ID
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async longSessionGet(longSessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.longSessionGet(longSessionID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.longSessionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates long session status
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {LongSessionUpdateReq} longSessionUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async longSessionUpdate(userID: string, longSessionID: string, longSessionUpdateReq: LongSessionUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.longSessionUpdate(userID, longSessionID, longSessionUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.longSessionUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new short session
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {ShortSessionCreateReq} shortSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shortSessionCreate(userID: string, longSessionID: string, shortSessionCreateReq: ShortSessionCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shortSessionCreate(userID, longSessionID, shortSessionCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.shortSessionCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a long session by ID and user ID
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLongSessionGet(userID: string, longSessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLongSessionGet(userID, longSessionID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.userLongSessionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Create a new long session
         * @param {string} userID ID of user
         * @param {LongSessionCreateReq} longSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionCreate(userID: string, longSessionCreateReq: LongSessionCreateReq, options?: any): AxiosPromise<LongSession> {
            return localVarFp.longSessionCreate(userID, longSessionCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a long session by ID
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionGet(longSessionID: string, options?: any): AxiosPromise<LongSession> {
            return localVarFp.longSessionGet(longSessionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates long session status
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {LongSessionUpdateReq} longSessionUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        longSessionUpdate(userID: string, longSessionID: string, longSessionUpdateReq: LongSessionUpdateReq, options?: any): AxiosPromise<LongSession> {
            return localVarFp.longSessionUpdate(userID, longSessionID, longSessionUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new short session
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {ShortSessionCreateReq} shortSessionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shortSessionCreate(userID: string, longSessionID: string, shortSessionCreateReq: ShortSessionCreateReq, options?: any): AxiosPromise<ShortSession> {
            return localVarFp.shortSessionCreate(userID, longSessionID, shortSessionCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a long session by ID and user ID
         * @param {string} userID ID of user
         * @param {string} longSessionID ID of long session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLongSessionGet(userID: string, longSessionID: string, options?: any): AxiosPromise<LongSession> {
            return localVarFp.userLongSessionGet(userID, longSessionID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Create a new long session
     * @param {string} userID ID of user
     * @param {LongSessionCreateReq} longSessionCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public longSessionCreate(userID: string, longSessionCreateReq: LongSessionCreateReq, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).longSessionCreate(userID, longSessionCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a long session by ID
     * @param {string} longSessionID ID of long session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public longSessionGet(longSessionID: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).longSessionGet(longSessionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates long session status
     * @param {string} userID ID of user
     * @param {string} longSessionID ID of long session
     * @param {LongSessionUpdateReq} longSessionUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public longSessionUpdate(userID: string, longSessionID: string, longSessionUpdateReq: LongSessionUpdateReq, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).longSessionUpdate(userID, longSessionID, longSessionUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new short session
     * @param {string} userID ID of user
     * @param {string} longSessionID ID of long session
     * @param {ShortSessionCreateReq} shortSessionCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public shortSessionCreate(userID: string, longSessionID: string, shortSessionCreateReq: ShortSessionCreateReq, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).shortSessionCreate(userID, longSessionID, shortSessionCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a long session by ID and user ID
     * @param {string} userID ID of user
     * @param {string} longSessionID ID of long session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public userLongSessionGet(userID: string, longSessionID: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).userLongSessionGet(userID, longSessionID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an existing credential (passkey)
         * @param {string} userID ID of user
         * @param {string} credentialID ID of credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialDelete: async (userID: string, credentialID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('credentialDelete', 'userID', userID)
            // verify required parameter 'credentialID' is not null or undefined
            assertParamExists('credentialDelete', 'credentialID', credentialID)
            const localVarPath = `/users/{userID}/credentials/{credentialID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"credentialID"}}`, encodeURIComponent(String(credentialID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of credentials (passkeys)
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialList: async (userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('credentialList', 'userID', userID)
            const localVarPath = `/users/{userID}/credentials`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new social account
         * @param {string} userID ID of user
         * @param {SocialAccountCreateReq} socialAccountCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialAccountCreate: async (userID: string, socialAccountCreateReq: SocialAccountCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('socialAccountCreate', 'userID', userID)
            // verify required parameter 'socialAccountCreateReq' is not null or undefined
            assertParamExists('socialAccountCreate', 'socialAccountCreateReq', socialAccountCreateReq)
            const localVarPath = `/users/{userID}/socialAccounts`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(socialAccountCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of social accounts
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialAccountList: async (sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/socialAccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user
         * @param {UserCreateReq} userCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate: async (userCreateReq: UserCreateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateReq' is not null or undefined
            assertParamExists('userCreate', 'userCreateReq', userCreateReq)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('userDelete', 'userID', userID)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('userGet', 'userID', userID)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of social accounts
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialAccountList: async (userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('userSocialAccountList', 'userID', userID)
            const localVarPath = `/users/{userID}/socialAccounts`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user
         * @param {string} userID ID of user
         * @param {UserUpdateReq} userUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate: async (userID: string, userUpdateReq: UserUpdateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('userUpdate', 'userID', userID)
            // verify required parameter 'userUpdateReq' is not null or undefined
            assertParamExists('userUpdate', 'userUpdateReq', userUpdateReq)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an existing credential (passkey)
         * @param {string} userID ID of user
         * @param {string} credentialID ID of credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialDelete(userID: string, credentialID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialDelete(userID, credentialID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.credentialDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of credentials (passkeys)
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialList(userID, sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.credentialList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new social account
         * @param {string} userID ID of user
         * @param {SocialAccountCreateReq} socialAccountCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async socialAccountCreate(userID: string, socialAccountCreateReq: SocialAccountCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SocialAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.socialAccountCreate(userID, socialAccountCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.socialAccountCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of social accounts
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async socialAccountList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SocialAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.socialAccountList(sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.socialAccountList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new user
         * @param {UserCreateReq} userCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreate(userCreateReq: UserCreateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreate(userCreateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.userCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDelete(userID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDelete(userID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.userDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(userID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(userID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.userGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of social accounts
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSocialAccountList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SocialAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSocialAccountList(userID, sort, filter, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.userSocialAccountList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates a user
         * @param {string} userID ID of user
         * @param {UserUpdateReq} userUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdate(userID: string, userUpdateReq: UserUpdateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdate(userID, userUpdateReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.userUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Deletes an existing credential (passkey)
         * @param {string} userID ID of user
         * @param {string} credentialID ID of credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialDelete(userID: string, credentialID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.credentialDelete(userID, credentialID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of credentials (passkeys)
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<CredentialList> {
            return localVarFp.credentialList(userID, sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new social account
         * @param {string} userID ID of user
         * @param {SocialAccountCreateReq} socialAccountCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialAccountCreate(userID: string, socialAccountCreateReq: SocialAccountCreateReq, options?: any): AxiosPromise<SocialAccount> {
            return localVarFp.socialAccountCreate(userID, socialAccountCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of social accounts
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialAccountList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<SocialAccountList> {
            return localVarFp.socialAccountList(sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user
         * @param {UserCreateReq} userCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(userCreateReq: UserCreateReq, options?: any): AxiosPromise<User> {
            return localVarFp.userCreate(userCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(userID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.userDelete(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a user
         * @param {string} userID ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(userID: string, options?: any): AxiosPromise<User> {
            return localVarFp.userGet(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of social accounts
         * @param {string} userID ID of user
         * @param {string} [sort] Field sorting
         * @param {Array<string>} [filter] Field filtering
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialAccountList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<SocialAccount>> {
            return localVarFp.userSocialAccountList(userID, sort, filter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user
         * @param {string} userID ID of user
         * @param {UserUpdateReq} userUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(userID: string, userUpdateReq: UserUpdateReq, options?: any): AxiosPromise<User> {
            return localVarFp.userUpdate(userID, userUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Deletes an existing credential (passkey)
     * @param {string} userID ID of user
     * @param {string} credentialID ID of credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public credentialDelete(userID: string, credentialID: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).credentialDelete(userID, credentialID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of credentials (passkeys)
     * @param {string} userID ID of user
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public credentialList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).credentialList(userID, sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new social account
     * @param {string} userID ID of user
     * @param {SocialAccountCreateReq} socialAccountCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public socialAccountCreate(userID: string, socialAccountCreateReq: SocialAccountCreateReq, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).socialAccountCreate(userID, socialAccountCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of social accounts
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public socialAccountList(sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).socialAccountList(sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user
     * @param {UserCreateReq} userCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userCreate(userCreateReq: UserCreateReq, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userCreate(userCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user
     * @param {string} userID ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDelete(userID: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userDelete(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a user
     * @param {string} userID ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGet(userID: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGet(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of social accounts
     * @param {string} userID ID of user
     * @param {string} [sort] Field sorting
     * @param {Array<string>} [filter] Field filtering
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userSocialAccountList(userID: string, sort?: string, filter?: Array<string>, page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userSocialAccountList(userID, sort, filter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user
     * @param {string} userID ID of user
     * @param {UserUpdateReq} userUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdate(userID: string, userUpdateReq: UserUpdateReq, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userUpdate(userID, userUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



